////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// eval.cpp                                                                   //
//                                                                            //
// Copyright Matthew Gingell <gingell@adacore.com>, 2009. Chesley the         //
// Chess Engine! is free software distributed under the terms of the          //
// GNU Public License.                                                        //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "chesley.hpp"

#include <iostream>

using namespace std;

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//  piece_square_table:                                                //
//                                                                     //
//  This is a table of bonuses for each piece-location pair. The table //
//  is written in 'reverse' for readability and a transformation is    //
//  required for fetching values for black and white.                  //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

const int xfrm[2][64] = 
  {
      // Transformation for white.
      {
        56,  57,  58,  59,  60,  61,  62,  63,
        48,  49,  50,  51,  52,  53,  54,  55,
        40,  41,  42,  43,  44,  45,  46,  47,
        32,  33,  34,  35,  36,  37,  38,  39,
        24,  25,  26,  27,  28,  29,  30,  31,
        16,  17,  18,  19,  20,  21,  22,  23,
         8,   9,  10,  11,  12,  13,  14,  15,
         0,   1,   2,   3,   4,   5,   6,   7
      },

      // Transformation for black.
      {
         0,   1,   2,   3,   4,   5,   6,   7,
         8,   9,  10,  11,  12,  13,  14,  15,
        16,  17,  18,  19,  20,  21,  22,  23,
        24,  25,  26,  27,  28,  29,  30,  31,
        32,  33,  34,  35,  36,  37,  38,  39,
        40,  41,  42,  43,  44,  45,  46,  47,
        48,  49,  50,  51,  52,  53,  54,  55,
        56,  57,  58,  59,  60,  61,  62,  63,
      }
  };

const Score piece_square_table[2][6][64] =
  {
    // Values used in the opening.
    {

      // Pawns
      {
         0,   0,   0,   0,   0,   0,   0,   0,
        50,  50,  50,  50,  50,  50,  50,  50,
        10,  10,  15,  25,  25,  15,  10,  10,
         5,   5,  10,  20,  20,  10,   5,   5,
         0,   0,   5,  10,  10,   5,   0,   0,
         0,   0,   0, -20, -20,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0
      },

      // Rooks
      {
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0
      },

      // Knights
      {
       -50, -20, -20, -10, -10, -20, -20, -50,
        -0,  15,  15,  25,  25,  15,  15,   0,
         0,  15,  20,  25,  25,  20,   0,   0,
         0,  10,  20,  25,  25,  20,  10,   0,
         0,  10,  15,  20,  20,  15,  10,   0,
         0,   0,  15,  10,  10,  15,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
       -50, -20, -20, -20, -20, -20, -20, -50
      },

      // Bishops
      {
         0,   0,   0,   5,   5,   0,   0,   0,
         0,   5,   5,   5,   5,   5,   5,   0,
         0,   5,  10,  10,  10,  10,   5,   0,
         0,   5,  10,  15,  15,  10,   5,   0,
         0,   5,  10,  15,  15,  10,   5,   0,
         0,   5,  10,  10,  10,  10,   5,   0,
         0,   5,   5,   5,   5,   5,   5,   0,
       -10, -10, -10,  -5,  -5,  10,  10, -10
      },

      // Queens
      {
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0
      },

      // Kings
      {
        -40, -40, -40, -40, -40, -40, -40, -40,
        -40, -40, -40, -40, -40, -40, -40, -40,
        -40, -40, -40, -40, -40, -40, -40, -40,
        -40, -40, -40, -40, -40, -40, -40, -40,
        -40, -40, -40, -40, -40, -40, -40, -40,
        -40, -40, -40, -40, -40, -40, -40, -40,
        -20, -20, -20, -20, -20, -20, -20, -20,
          0,  20,  40, -20,   0, -20,  40,  20
      }

    },

    // Values used in the end game.
    {

      // Pawns
      {
         0,   0,   0,   0,   0,   0,   0,   0,
        50,  50,  50,  50,  50,  50,  50,  50,
        10,  10,  15,  25,  25,  15,  10,  10,
         5,   5,  10,  20,  20,  10,   5,   5,
         0,   0,   5,  10,  10,   5,   0,   0,
         0,   0,   0, -20, -20,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0
      },

      // Rooks
      {
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0
      },

      // Knights
      {
       -50, -20, -20, -10, -10, -20, -20, -50,
        -0,  15,  15,  25,  25,  15,  15,   0,
         0,  15,  20,  25,  25,  20,   0,   0,
         0,  10,  20,  25,  25,  20,  10,   0,
         0,  10,  15,  20,  20,  15,  10,   0,
         0,   0,  15,  10,  10,  15,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
       -50, -20, -20, -20, -20, -20, -20, -50
      },

      // Bishops
      {
         0,   0,   0,   5,   5,   0,   0,   0,
         0,   5,   5,   5,   5,   5,   5,   0,
         0,   5,  10,  10,  10,  10,   5,   0,
         0,   5,  10,  15,  15,  10,   5,   0,
         0,   5,  10,  15,  15,  10,   5,   0,
         0,   5,  10,  10,  10,  10,   5,   0,
         0,   5,   5,   5,   5,   5,   5,   0,
       -10, -10, -10,  -5,  -5,  10,  10, -10
      },

      // Queens
      {
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0,
         0,   0,   0,   0,   0,   0,   0,   0
      },

      // Kings
      {
        -40, -40, -40, -40, -40, -40, -40, -40,
        -40, -40, -40, -40, -40, -40, -40, -40,
        -40, -40, -40, -40, -40, -40, -40, -40,
        -40, -40, -40, -40, -40, -40, -40, -40,
        -40, -40, -40, -40, -40, -40, -40, -40,
        -40, -40, -40, -40, -40, -40, -40, -40,
        -20, -20, -20, -20, -20, -20, -20, -20,
          0,  20,  40, -20,   0, -20,  40,  20
      }
    }
  };


    //////////////////////////////////////
    // Evaluation function entry point. //
    //////////////////////////////////////

    Score 
    Eval::score () { 
      Score s = 0;

      // Simple material value.
      s = b.material[WHITE] - 
        b.material[BLACK];

      // Piece square values.
      s += (b.psquares[WHITE][OPENING_PHASE]) - 
        (b.psquares[BLACK][OPENING_PHASE]);

#if 0
      // Evaluate mobility.
      s += score_mobility (WHITE) - 
        score_mobility (BLACK);
#endif

      return sign (b.to_move ()) * s;
    }

    Score
    Eval::score_mobility (const Color c) {
      Score s = 0;

      // Rooks
      bitboard pieces = b.get_rooks (c);
      while (pieces) {
        Coord idx = bit_idx (pieces);
        s += b.rook_mobility (idx);
        clear_bit (pieces, idx);
      }

      // Knights
      pieces = b.get_knights (c);
      while (pieces) {
        Coord idx = bit_idx (pieces);
        s += b.knight_mobility (idx);
        clear_bit (pieces, idx);
      }

      // Bishops
      pieces = b.get_bishops (c);
      while (pieces) {
        Coord idx = bit_idx (pieces);
        s += b.bishop_mobility (idx);
        clear_bit (pieces, idx);
      }

      // Queens
      pieces = b.get_queens (c);
      while (pieces) {
        Coord idx = bit_idx (pieces);
        s += b.queen_mobility (idx);
        clear_bit (pieces, idx);
      }
  
      return s;
    }
