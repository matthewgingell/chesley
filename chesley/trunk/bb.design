Can expand 5.25 millions positions per second!

 Notes on bitboard implementation of chess board states and their
 operations:

 * Board layout and coordinate system:

  Bitwise for addressing:

  7 . . . . . . . .  byte 7
  6 . . . . . . . .  byte 6
  5 . . . . . . . .  byte 5
  4 . . . . . . . .  byte 4
  3 . . . . . . . .  byte 3
  2 . . . . . . . .  byte 2
  1 . . . . . . . .  byte 1
  0 . . . . . . . .  byte 0
    0 1 2 3 4 5 6 7

  Algebraic notaion:

  8 . . . . . . . .
  7 . . . . . . . .
  6 . . . . . . . .
  5 . . . . . . . .
  4 . . . . . . . .
  3 . . . . . . . .
  2 . . . . . . . .
  1 . . . . . . . .
    a b c d e f g h

  Bit ordering:

  Rotations: example in the  3x3 case:

  6 7 8          
  3 4 5  Rot. 0 =
  0 1 2          

    8
   7 5             7 5 8
  6 4 2  Rot. 45 = 6 4 2
   3 1             0 3 1
    0

  8 5 2
  7 4 1  Rot. 90 
  6 3 0

    2
   5 1              5 1 2
  8 4 0  Rot. 135 = 8 4 0
   7 3              6 7 3
    6


  Rot 0:                     Rot 0:

  56 57 58 59 60 61 62 63      56 57 58 59 60 61 62 63
  48 49 50 51 52 53 54 55      48 49 50 51 52 53 54 55
  40 41 42 43 44 45 46 47      40 41 42 43 44 45 46 47
  32 33 34 35 36 37 38 39  ==> 32 33 34 35 36 37 38 39
  24 25 26 27 28 29 30 31      24 25 26 27 28 29 30 31
  16 17 18 19 20 21 22 23      16 17 18 19 20 21 22 23
  08 09 10 11 12 13 14 15      08 09 10 11 12 13 14 15
  00 01 02 03 04 05 06 07      00 01 02 03 04 05 06 07


  Rot 45:

  56 57 58 59 60 61 62 63
  48 49 50 51 52 53 54 55
  40 41 42 43 44 45 46 47
  32 33 34 35 36 37 38 39  ==>
  24 25 26 27 28 29 30 31
  16 17 18 19 20 21 22 23
  08 09 10 11 12 13 14 15
  00 01 02 03 04 05 06 07


               63
             62  55
     	   61  54  47                  Rot 45:
       	 60  53  46  39                
       59  52  45  38  31              46 39 61 54 55 62 55 63
     58  51  44  37  30  23	       23 59 52 45 38 31 60 53
   57  50  43  36  29  22  15	       29 22 15 58 51 44 37 30
 56  49  42  35  28  21  14  07   ==>  28 21 14 07 57 50 43 36
   48  41  34  27  20  13  06	       27 20 13 06 56 49 42 35
     40  33  26  19  12  05	       33 26 18 11 04 48 41 34
       32  25  18  11  04	       10 03 32 25 18 11 04 40
         24  17  10  03		       00 08 01 16 09 02 24 17
	   16  09  02                                         
             08  01
               00



  Rot 0:		      Rot 90:		     
  			                             
  56 57 58 59 60 61 62 63     63 55 47 39 31 23 15 07
  48 49 50 51 52 53 54 55     62 54 46 38 30 22 14 06
  40 41 42 43 44 45 46 47     61 53 45 37 29 21 13 05
  32 33 34 35 36 37 38 39 ==> 60 52 44 36 28 20 12 04
  24 25 26 27 28 29 30 31     59 51 43 35 27 19 11 03
  16 17 18 19 20 21 22 23     58 50 42 34 26 18 10 02
  08 09 10 11 12 13 14 15     57 49 41 33 25 17 09 01
  00 01 02 03 04 05 06 07     56 48 40 32 24 16 08 00

  Rot 0:

  56 57 58 59 60 61 62 63
  48 49 50 51 52 53 54 55
  40 41 42 43 44 45 46 47
  32 33 34 35 36 37 38 39  ==>
  24 25 25 27 28 29 30 31
  16 17 18 19 20 21 22 23
  08 09 10 11 12 13 14 15
  00 01 02 03 04 05 06 07

  Rot 135:

               07
             15  06
           23  14  05
         31  22  13  04             
       39  30  21  12  03	      13 04 23 14 05 15 06 07
     47  38  29  20  11  02	      02 39 30 21 12 03 31 22
   55  46  37  28  19  10  01	      19 10 01 47 38 29 20 11
 63  54  45  36  27  18  09  00  ==>  27 18 09 00 55 46 37 28
   62  53  44  35  26  17  08	      35 26 17 08 63 54 45 36
     61  52  43  34  25  16	      52 43 34 25 16 62 53 44
       60  51  42  33  24	      41 32 60 51 42 33 24 61
         59  50  41  32		      56 57 48 58 50 42 59 50
           58  49  40
             57  48
               56


Generating moves along diagonals:

'from' = <some normal index number>

Fetch occupany pattern for 'from' with occ_45 (from):
   shift occupied_45 approriately and return the first byte:
      shift occupied_45 by shift_table[from] 
      return first byte.
Lookup possible moves in DIAG_45_ATTACKS_TBL[from * 256 + pattern]

Generate DIAG_45_ATTACKS_TBL
  init table.
  for each position 0 .. 63
    for each pattern 0 .. 255
      compute moves available at position with pattern.

How do I know where in the byte I am?

  use diag_bitpos[]
              
How do I know the length of this diagonal?

  use diag_widths[]

eg pattern is 00101111
              ^ ^   ^
              | |   |
          first pos last

Castling:

Castling is permissible only if all of the following conditions hold: (Schiller 2001:19)

   1. The king must never have moved;
   2. The chosen rook must never have moved;
   3. There must be no pieces between the king and the chosen rook;
   4. The king must not currently be in check.
   5. The king must not pass through a square that is under attack by enemy pieces.
   6. The king must not end up in check (true of any legal move).
   7. The king and the chosen rook must be on the same rank.[2]

King may move to X, rook to inner file next to king.

  8 r . X q k . X r
  7 . . . . . . . .
  6 . . . . . . . .
  5 . . . . . . . .
  4 . . . . . . . .
  3 . . . . . . . .
  2 . . . . . . . .
  1 R . X Q K . X R
    a b c d e f g h

White:

 
  



