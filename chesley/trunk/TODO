Issues:

  * How do I know if a move returned by the search is correct? How do
    I know it's any good?

  * Detect insufficient material to mate.

Next items:

  * 8/k7/3p4/p2P1p2/P2P1P2/8/8/K7 w - - 0 1: best move is Ka1b1. Must
    search to play 20, which is nearly free with trans tables. Check
    it in testsuite.

  * Return draw at 50 move rule, even if somebody is in check.

  * Convert ostring functions to to_string functions.

  * Hunt for things that can be made const.

  * Use 16 bit types for indexes, scores, and depths.

  * Must have a good way of measuring search correctness, strength,
    and speed before we try to improved them.

  * Document MTDf

  * Collect and analyize search statistics.

  * Use readline and completions.

  * Add help command.

Interface:

  * Finish and clean up implementation of Xboard protocol.
  * Do validity checking.

Clean up:

  * Move util stuff to a .cpp?

  * We use a weird mix of C++ string and C char *, and C++ iostreams
    and C FILE *. Each of these has real advantages in th appropriate
    setting, but we really ought to be able to normalize our usage
    somewhat.

Testing:

  * Add log and debugging infrastructure.
  * Setup automated regression testing.

Session

  * Implement Xboard protocol.

Search

  * Implement 3 fold repetition detection. Right now Chesley plays and
    incredibly irritating end game, repeatedly running the half move
    clock up to 49 then moving a pawn...
  * Quiescence search
  * Time management 
  * Aspiration windows
  * Static Exchange Evaluation (SEE) for capture ordering.
  * Null move heuristic

  Debug MTD(f)

Eval

  * Reward good pawn structure.
  * Do some research....
