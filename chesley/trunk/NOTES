Would love to have alpha beta return / compute principle variation.

 - Similar but different objectives

   * Score a position.
   * Score a move.
   * Find the best move from a position.
   * Find the child with the highest core.
   * Find the principle variation.


integer       i
position      p
move          m
move vector   <m>
pos. vector   <p>

p (m) => p


apply (p, m) => p'
moves (p)    => <m>
score (p)    => i
    

for m in moves (p)
  p' = apply (p, m)
  

gray-matter:

void search_base::extract_pv()
{

/// Extract the principal variation from the transposition table.

    move_t m;
    pv.clear();

    for (table_ptr->probe(board_ptr->get_hash(), 0, EXACT, &m); 
         !m.is_null() && board_ptr->get_status(true) == IN_PROGRESS;
         table_ptr->probe(board_ptr->get_hash(), 0, EXACT, &m))
    {
        pv.push_back(m);
        board_ptr->make(m);
        if (pv.size() == (unsigned) max_depth)
            break;
    }
    for (size_t j = 0; j < pv.size(); j++)
        board_ptr->unmake();
}

// Lookup and apply best move in transposition table repeatedly to
// extract principle variation.

for m = lookup (board); move != null; m = lookup (board)
   board = board.apply (m)

have alphabeta return a <move, score> type!
